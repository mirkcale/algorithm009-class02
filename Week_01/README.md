# 学习笔记

### 解答 plus-one 这个问题的思考

在解答这道题的时候，我想到的是小学学的列竖式，从末尾开始相加，逢十进位。前一位加一。时间复杂度$O(n)$


### 两数之和
现在在解每题之前，我都会尝试暴力解法，然后再试试其他解法，首次是暴力遍历解法，从数组开头开始遍历，然后在次基础上再加一层遍历，如果双重遍历的值相同则跳过内层的本次循环，如果两数之和与目标相等，则返回两个下标。
暴力解法的时间复杂度为$O(n^2)$

第二种解法，遍历数组，使用hash来存储，以期望的值为key，保存下标，再次遍历数组的时候，查找期望值是当前的值，注意需要排重（下标不与当前下标相同）

第三种解法，使用hashmap辅助查找，一次遍历，以期望值（$target - 当前值 $）为key，保存在hashmap中，查找map中是否存在期望值，如果存在且值与当前下标不一致，返回当前下标与map中期望值对应的下标。

第二三种解法时间复杂度都是$O(n)$

### 合并有序的两个链表

首先想到的是while循环，遍历两个链表。解法过程，新建一个虚拟头节点`dummy`，然后新建游标`move`指向虚拟头节点,遍历两个链表，比较两个链表当前节点的`val`大小，`move->next` 指向 `val`小的链表的当前节点，然后该链表的当前节点往后移一个节点，同时 `move`游标也往后移动一个节点， 当两个链表有一个无后继节点时，`move`指向有后继节点的那个链表，最后返回`dummy->next`。递归的思路是一样的。返回两个节点中，存在或者节点val小的那个，该节点的next调用`本身->next`与另一个链表比较